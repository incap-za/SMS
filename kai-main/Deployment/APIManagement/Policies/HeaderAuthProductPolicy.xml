<!--
    IMPORTANT:
    - Policy elements can appear only within the <inbound>, <outbound>, <backend> section elements.
    - To apply a policy to the incoming request (before it is forwarded to the backend service), place a corresponding policy element within the <inbound> section element.
    - To apply a policy to the outgoing response (before it is sent back to the caller), place a corresponding policy element within the <outbound> section element.
    - To add a policy, place the cursor at the desired insertion point and select a policy from the sidebar.
    - To remove a policy, delete the corresponding policy statement from the policy document.
    - Position the <base> element within a section element to inherit all policies from the corresponding section element in the enclosing scope.
    - Remove the <base> element to prevent inheriting policies from the corresponding section element in the enclosing scope.
    - Policies are applied in the order of their appearance, from the top down.
    - Comments within policy elements are not supported and may disappear. Place your comments between policy elements or at a higher level scope.
-->
<policies>
    <inbound>
        <set-variable name="contentTypeHeader" value="@{
            string[] value;
            if (context.Request.Headers.TryGetValue("content-type", out value))
            {
                if (value != null && value.Length > 0)
                {
                    return value[0].Replace("\"","");
                }
            }
            return String.Empty;

      }" />
        <set-header name="Content-Type" exists-action="override">
            <value>"@((string)context.Variables["contentTypeHeader"])"</value>
        </set-header>
        <set-variable name="contentType" value="@{
            if(context.Api.Name.Contains("SOAP")){
                return "text/xml";
            }

            return "application/json";
        }" />
        <set-variable name="jsonErrorFormat" value="@{
            return "{{\"error\": {{\"code\": \"{0}\", \"message\": \"{1}\"}}}}";
        }" />
        <set-variable name="xmlErrorFormat" value="@{
            return "<s:Envelope xmlns:s='http://schemas.xmlsoap.org/soap/envelope/'><s:Body><s:Fault><faultcode>s:Client</faultcode><faultstring xml:lang='en-IN'>{0}</faultstring></s:Fault></s:Body></s:Envelope>";
        }" />
        <set-variable name="username" value="@{
            // Get the username from the SOAP header
            string strXml = context.Request.Body.As<string>(preserveContent: true);
            XmlDocument xDoc = new XmlDocument();
            xDoc.LoadXml(strXml);
            XmlNodeList userTokenNode = xDoc.GetElementsByTagName("Username", "*");
            string userToken = userTokenNode.Item(0).InnerXml;
            return userToken;
        }" />
        <set-variable name="password" value="@{
            // Get the password from the SOAP header
            string strXml = context.Request.Body.As<string>(preserveContent: true);
            XmlDocument xDoc = new XmlDocument();
            xDoc.LoadXml(strXml);
            XmlNodeList userTokenNode = xDoc.GetElementsByTagName("Password", "*");
            string userToken = userTokenNode.Item(0).InnerXml;
            return userToken;
        }" />
        <!-- 2020-03-09 Validation of filled username parameter -->
        <choose>
            <when condition="@(string.IsNullOrEmpty((string)context.Variables["username"]))">
                <return-response response-variable-name="Forbidden">
                    <set-status code="401" reason="Unauthorized" />
                    <set-header name="WWW-Authenticate" exists-action="override">
                        <value>Basic realm="KPN B2B System"</value>
                    </set-header>
                    <set-header name="Content-Type" exists-action="override">
                        <value>@((string)context.Variables["contentType"])</value>
                    </set-header>
                    <!-- Introduce headers as result of Pen-test recommendations -->
                    <!-- Removal commented; in fact header is needed to prevent downgrade attacks - enforcing HTTPS-->
                    <!--set-header name="Strict-Transport-Security" exists-action="delete" /-->
                    <!-- Setting preventing Downgrade attacks-->
                    <set-header name="Strict-Transport-Security" exists-action="override">
                        <value>max-age=31536000; includeSubDomains</value>
                    </set-header>
                    <!-- Setting preventing Clickjacking attacks-->
                    <set-header name="X-Frame-Options" exists-action="override">
                        <value>Deny</value>
                    </set-header>
                    <!-- Setting preventing CSP misuse; extended by proposed of OSO - Munzur - 8-3-2019-->
                    <set-header name="Content-Security-Policy" exists-action="override">
                        <value>frame-ancestors 'none'; default-src 'none'; script-src 'self'</value>
                    </set-header>
                    <!-- Adjusting Pragma-value (not sure if needed?)-->
                    <set-header name="Pragma" exists-action="override">
                        <value>no-cache</value>
                    </set-header>
                    <!-- Adjusting Cache-control-value (not sure if needed?)-->
                    <set-header name="Cache-control" exists-action="override">
                        <value>no-cache</value>
                    </set-header>
                    <!-- Adjusting Referrer-Policy value (Disable referrers for browsers that don't support strict-origin-when-cross-origin; Uses strict-origin-when-cross-origin for browsers that do)-->
                    <set-header name="Referrer-Policy" exists-action="override">
                        <value>no-referrer, strict-origin-when-cross-origin</value>
                    </set-header>
                    <!-- Prevent CORS with whitelist origin domain-->
                    <set-header name="Access-Control-Allow-Origin" exists-action="override">
                        <value>{{BasicAuth_AccessControlAllowOrigin}}</value>
                    </set-header>
                    <!-- Setting XSS protection; no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-XSS-Protection">
                        <value>1; mode=block</value>
                    </set-header>
                    <!-- Prevents content type from being exposed (needs to be set); no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-Content-Type-Options">
                        <value>nosniff</value>
                    </set-header>
                    <!-- Additional proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-Permitted-Cross-Domain-Policies">
                        <value>none</value>
                    </set-header>
                    <set-body>@{
                          string code = "AuthenticationFailure";
                          string message = "User is not provided";
                          string formattedBody = string.Empty;
                          if((string)context.Variables["contentType"] == "application/json"){
                              formattedBody = string.Format((string)context.Variables["jsonErrorFormat"], code, message);
                          }
                          else{
                              formattedBody = string.Format((string)context.Variables["xmlErrorFormat"], message);
                          }
                          return formattedBody;
                      }</set-body>
                </return-response>
            </when>
            <!-- 2020-03-09 Validation of filled password parameter -->
            <when condition="@(string.IsNullOrEmpty((string)context.Variables["password"]))">
                <return-response response-variable-name="Forbidden">
                    <set-status code="401" reason="Unauthorized" />
                    <set-header name="WWW-Authenticate" exists-action="override">
                        <value>Basic realm="KPN B2B System"</value>
                    </set-header>
                    <set-header name="Content-Type" exists-action="override">
                        <value>@((string)context.Variables["contentType"])</value>
                    </set-header>
                    <!-- Introduce headers as result of Pen-test recommendations -->
                    <!-- Removal commented; in fact header is needed to prevent downgrade attacks - enforcing HTTPS-->
                    <!--set-header name="Strict-Transport-Security" exists-action="delete" /-->
                    <!-- Setting preventing Downgrade attacks-->
                    <set-header name="Strict-Transport-Security" exists-action="override">
                        <value>max-age=31536000; includeSubDomains</value>
                    </set-header>
                    <!-- Setting preventing Clickjacking attacks-->
                    <set-header name="X-Frame-Options" exists-action="override">
                        <value>Deny</value>
                    </set-header>
                    <!-- Setting preventing CSP misuse; extended by proposed of OSO - Munzur - 8-3-2019-->
                    <set-header name="Content-Security-Policy" exists-action="override">
                        <value>frame-ancestors 'none'; default-src 'none'; script-src 'self'</value>
                    </set-header>
                    <!-- Adjusting Pragma-value (not sure if needed?)-->
                    <set-header name="Pragma" exists-action="override">
                        <value>no-cache</value>
                    </set-header>
                    <!-- Adjusting Cache-control-value (not sure if needed?)-->
                    <set-header name="Cache-control" exists-action="override">
                        <value>no-cache</value>
                    </set-header>
                    <!-- Adjusting Referrer-Policy value (Disable referrers for browsers that don't support strict-origin-when-cross-origin; Uses strict-origin-when-cross-origin for browsers that do)-->
                    <set-header name="Referrer-Policy" exists-action="override">
                        <value>no-referrer, strict-origin-when-cross-origin</value>
                    </set-header>
                    <!-- Prevent CORS with whitelist origin domain-->
                    <set-header name="Access-Control-Allow-Origin" exists-action="override">
                        <value>{{BasicAuth_AccessControlAllowOrigin}}</value>
                    </set-header>
                    <!-- Setting XSS protection; no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-XSS-Protection">
                        <value>1; mode=block</value>
                    </set-header>
                    <!-- Prevents content type from being exposed (needs to be set); no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-Content-Type-Options">
                        <value>nosniff</value>
                    </set-header>
                    <!-- Additional proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-Permitted-Cross-Domain-Policies">
                        <value>none</value>
                    </set-header>
                    <set-body>@{
                  string code = "AuthenticationFailure";
                  string message = "Password is not provided";
                  string formattedBody = string.Empty;
                  if((string)context.Variables["contentType"] == "application/json"){
                  formattedBody = string.Format((string)context.Variables["jsonErrorFormat"], code, message);
                  }
                  else{
                  formattedBody = string.Format((string)context.Variables["xmlErrorFormat"], message);
                  }
                  return formattedBody;
                  }</set-body>
                </return-response>
            </when>
        </choose>
        <!-- get client secret and convert to url encoded string -->
        <set-variable name="clientSecret" value="@{
            string password = "{{BasicAuth_ClientSecret}}";

            // create dictonary with special chars which need to be URL encoded
            Dictionary<char, string> keyValuePairs = new Dictionary<char, string>();
            keyValuePairs.Add(' ', "+");
            keyValuePairs.Add('#', "%23");
            keyValuePairs.Add('$', "%24");
            keyValuePairs.Add('%', "%25");
            keyValuePairs.Add('&', "%26");
            keyValuePairs.Add('\'', "%27");

            keyValuePairs.Add('+', "%2B");
            keyValuePairs.Add(',', "%2c");
            keyValuePairs.Add('/', "%2f");
            keyValuePairs.Add(':', "%3a");
            keyValuePairs.Add(';', "%3b");
            keyValuePairs.Add('<', "%3c");
            keyValuePairs.Add('=', "%3D");
            keyValuePairs.Add('>', "%3e");
            keyValuePairs.Add('?', "%3f");
            keyValuePairs.Add('@', "%40");
            keyValuePairs.Add('[', "%5b");
            keyValuePairs.Add('\\', "%5c");
            keyValuePairs.Add(']', "%5d");
            keyValuePairs.Add('^', "%5e");
            keyValuePairs.Add('`', "%60");
            keyValuePairs.Add('{', "%7b");
            keyValuePairs.Add('|', "%7c");
            keyValuePairs.Add('}', "%7d");
            keyValuePairs.Add('~', "%7e");

            string encodedPassword = "";
            foreach(char c in password)
            {
              if(keyValuePairs.ContainsKey(c))
              {
                // replace special chars with URL encoding
                encodedPassword += keyValuePairs[c];
              }
              else
              {
                encodedPassword += c;
              }
            }
            
            return encodedPassword;
          }" />
        <!-- request bearer token from AAD authorization server -->
        <send-request ignore-error="false" timeout="20" response-variable-name="bearerToken" mode="new">
            <set-url>{{BasicAuth_AuthorizationServer}}</set-url>
            <set-method>POST</set-method>
            <set-header name="Content-Type" exists-action="override">
                <value>application/x-www-form-urlencoded</value>
            </set-header>
            <set-body>@($"grant_type=client_credentials&client_id={{BasicAuth_ClientId}}&client_secret={context.Variables["clientSecret"]}&resource={{BasicAuth_ResourceId}}")</set-body>
        </send-request>
        <!-- validate token -->
        <!-- read response token -->
        <set-variable name="bearerTokenReq" value="@((String)((IResponse)context.Variables["bearerToken"]).Body.As<JObject>()["access_token"])" />
        <choose>
            <when condition="@(string.IsNullOrEmpty((string)context.Variables["bearerTokenReq"]))">
                <return-response response-variable-name="Unauthorized">
                    <set-status code="401" reason="Unauthorized" />
                    <set-header name="WWW-Authenticate" exists-action="override">
                        <value>Basic realm="KPN B2B System"</value>
                    </set-header>
                    <set-header name="Content-Type" exists-action="override">
                        <value>@((string)context.Variables["contentType"])</value>
                    </set-header>
                    <set-body>@{
                          string code = "AuthenticationFailure";
                          string message = "Provided username and password combination is not valid in KPN Active Directory (from policy)";
                          string formattedBody = string.Empty;
                          if((string)context.Variables["contentType"] == "application/json"){
                              formattedBody = string.Format((string)context.Variables["jsonErrorFormat"], code, message);
                          }
                          else{
                              formattedBody = string.Format((string)context.Variables["xmlErrorFormat"], message);
                          }
                          return formattedBody;
                    }</set-body>
                </return-response>
            </when>
        </choose>
        <!-- retrieve client authorization for requested api -->
        <send-request ignore-error="false" timeout="20" response-variable-name="functionAppReq" mode="new">
            <set-url>{{BasicAuth_FunctionAppUrl}}</set-url>
            <set-method>POST</set-method>
            <set-header name="Content-Type" exists-action="override">
                <value>application/json</value>
            </set-header>
            <set-header name="Authorization" exists-action="override">
                <value>@("Bearer " + (string)context.Variables["bearerTokenReq"])</value>
            </set-header>
            <set-header name="RequestAuthorization" exists-action="override">
                <!-- NOT NEEDED ANYMORE - THIS WAS BASIC AUTH CODE -->
                <!--value>@(context.Request.Headers.GetValueOrDefault("Authorization", ""))</value-->
                <!-- NOT NEEDED ANYMORE - THIS WAS RELATED TO DISABLED MANUAL ATTEMPT FOR URLDECODE -->
                <!--value>@("Basic " + Convert.ToBase64String(System.Text.ASCIIEncoding.ASCII.GetBytes(string.Format("{0}:{1}", context.Request.Url.Query.GetValueOrDefault("username", ""), context.Variables["paramAuthDecodedSecret"]))))</value-->
                <!-- NEW: This is the better way to consume the same function, passing username+password-parameters (with password urldecoded!) as base64-encoded Authorization header
                          Format: "Basic "+<base64-encoded '<user>:<password>'> -->
                <value>@("Basic " + Convert.ToBase64String(System.Text.ASCIIEncoding.ASCII.GetBytes(string.Format("{0}:{1}", context.Variables["username"], context.Variables["password"]))))</value>
            </set-header>
            <set-header name="RequestApi" exists-action="override">
                <value>@(context.Api.Name)</value>
            </set-header>
            <set-header name="RequestUri" exists-action="override">
                <value>@((string)context.Api.ServiceUrl.ToString())</value>
            </set-header>
        </send-request>
        <!-- read response status code -->
        <set-variable name="functionAppReqStatus" value="@((string)((IResponse)context.Variables["functionAppReq"]).StatusCode.ToString())" />
        <choose>
            <!-- Unauthorized -->
            <when condition="@((string)context.Variables["functionAppReqStatus"] == "401")">
                <return-response response-variable-name="Unauthorized">
                    <set-status code="401" reason="Unauthorized" />
                    <set-header name="WWW-Authenticate" exists-action="override">
                        <value>Basic realm="KPN B2B System"</value>
                    </set-header>
                    <set-header name="Content-Type" exists-action="override">
                        <value>@((string)context.Variables["contentType"])</value>
                    </set-header>
                    <!-- Introduce headers as result of Pen-test recommendations -->
                    <!-- Removal commented; in fact header is needed to prevent downgrade attacks - enforcing HTTPS-->
                    <!--set-header name="Strict-Transport-Security" exists-action="delete" /-->
                    <!-- Setting preventing Downgrade attacks-->
                    <set-header name="Strict-Transport-Security" exists-action="override">
                        <value>max-age=31536000; includeSubDomains</value>
                    </set-header>
                    <!-- Setting preventing Clickjacking attacks-->
                    <set-header name="X-Frame-Options" exists-action="override">
                        <value>Deny</value>
                    </set-header>
                    <!-- Setting preventing CSP misuse; extended by proposed of OSO - Munzur - 8-3-2019-->
                    <set-header name="Content-Security-Policy" exists-action="override">
                        <value>frame-ancestors 'none'; default-src 'none'; script-src 'self'</value>
                    </set-header>
                    <!-- Adjusting Pragma-value (not sure if needed?)-->
                    <set-header name="Pragma" exists-action="override">
                        <value>no-cache</value>
                    </set-header>
                    <!-- Adjusting Cache-control-value (not sure if needed?)-->
                    <set-header name="Cache-control" exists-action="override">
                        <value>no-cache</value>
                    </set-header>
                    <!-- Adjusting Referrer-Policy value (Disable referrers for browsers that don't support strict-origin-when-cross-origin; Uses strict-origin-when-cross-origin for browsers that do)-->
                    <set-header name="Referrer-Policy" exists-action="override">
                        <value>no-referrer, strict-origin-when-cross-origin</value>
                    </set-header>
                    <!-- Prevent CORS with whitelist origin domain-->
                    <set-header name="Access-Control-Allow-Origin" exists-action="override">
                        <value>{{BasicAuth_AccessControlAllowOrigin}}</value>
                    </set-header>
                    <!-- Setting XSS protection; no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-XSS-Protection">
                        <value>1; mode=block</value>
                    </set-header>
                    <!-- Prevents content type from being exposed (needs to be set); no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-Content-Type-Options">
                        <value>nosniff</value>
                    </set-header>
                    <!-- Additional proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-Permitted-Cross-Domain-Policies">
                        <value>none</value>
                    </set-header>
                    <set-body>@{
                          string code = "AuthenticationFailure";
                          string message = "Function access failure";
                          string formattedBody = string.Empty;
                          if((string)context.Variables["contentType"] == "application/json"){
                              formattedBody = string.Format((string)context.Variables["jsonErrorFormat"], code, message);
                          }
                          else{
                              formattedBody = string.Format((string)context.Variables["xmlErrorFormat"], message);
                          }
                          return formattedBody;
                      }</set-body>
                </return-response>
            </when>
            <when condition="@((string)context.Variables["functionAppReqStatus"] == "422")">
                <return-response>
                    <set-status code="403" reason="Forbidden" />
                    <set-header name="WWW-Authenticate" exists-action="override">
                        <value>Basic realm="KPN B2B System"</value>
                    </set-header>
                    <set-header name="Content-Type" exists-action="override">
                        <value>@((string)context.Variables["contentType"])</value>
                    </set-header>
                    <!-- Introduce headers as result of Pen-test recommendations -->
                    <!-- Removal commented; in fact header is needed to prevent downgrade attacks - enforcing HTTPS-->
                    <!--set-header name="Strict-Transport-Security" exists-action="delete" /-->
                    <!-- Setting preventing Downgrade attacks-->
                    <set-header name="Strict-Transport-Security" exists-action="override">
                        <value>max-age=31536000; includeSubDomains</value>
                    </set-header>
                    <!-- Setting preventing Clickjacking attacks-->
                    <set-header name="X-Frame-Options" exists-action="override">
                        <value>Deny</value>
                    </set-header>
                    <!-- Setting preventing CSP misuse; extended by proposed of OSO - Munzur - 8-3-2019-->
                    <set-header name="Content-Security-Policy" exists-action="override">
                        <value>frame-ancestors 'none'; default-src 'none'; script-src 'self'</value>
                    </set-header>
                    <!-- Adjusting Pragma-value (not sure if needed?)-->
                    <set-header name="Pragma" exists-action="override">
                        <value>no-cache</value>
                    </set-header>
                    <!-- Adjusting Cache-control-value (not sure if needed?)-->
                    <set-header name="Cache-control" exists-action="override">
                        <value>no-cache</value>
                    </set-header>
                    <!-- Adjusting Referrer-Policy value (Disable referrers for browsers that don't support strict-origin-when-cross-origin; Uses strict-origin-when-cross-origin for browsers that do)-->
                    <set-header name="Referrer-Policy" exists-action="override">
                        <value>no-referrer, strict-origin-when-cross-origin</value>
                    </set-header>
                    <!-- Prevent CORS with whitelist origin domain-->
                    <set-header name="Access-Control-Allow-Origin" exists-action="override">
                        <value>{{BasicAuth_AccessControlAllowOrigin}}</value>
                    </set-header>
                    <!-- Setting XSS protection; no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-XSS-Protection">
                        <value>1; mode=block</value>
                    </set-header>
                    <!-- Prevents content type from being exposed (needs to be set); no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-Content-Type-Options">
                        <value>nosniff</value>
                    </set-header>
                    <!-- Additional proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-Permitted-Cross-Domain-Policies">
                        <value>none</value>
                    </set-header>
                    <set-body>@{
                          string code = "AuthorizationFailureParamAuth";
                          string message = (string)((IResponse)context.Variables["functionAppReq"]).Body.As<JObject>()["error"]["message"];
                          string formattedBody = string.Empty;
                          if((string)context.Variables["contentType"] == "application/json"){
                              formattedBody = string.Format((string)context.Variables["jsonErrorFormat"], code, message);
                          }
                          else{
                              formattedBody = string.Format((string)context.Variables["xmlErrorFormat"], message);
                          }
                          return formattedBody;
                    }</set-body>
                </return-response>
            </when>
            <when condition="@((string)context.Variables["functionAppReqStatus"] == "500")">
                <return-response>
                    <set-status code="500" reason="Server Error" />
                    <set-header name="Content-Type" exists-action="override">
                        <value>@((string)context.Variables["contentType"])</value>
                    </set-header>
                    <!-- Introduce headers as result of Pen-test recommendations -->
                    <!-- Removal commented; in fact header is needed to prevent downgrade attacks - enforcing HTTPS-->
                    <!--set-header name="Strict-Transport-Security" exists-action="delete" /-->
                    <!-- Setting preventing Downgrade attacks-->
                    <set-header name="Strict-Transport-Security" exists-action="override">
                        <value>max-age=31536000; includeSubDomains</value>
                    </set-header>
                    <!-- Setting preventing Clickjacking attacks-->
                    <set-header name="X-Frame-Options" exists-action="override">
                        <value>Deny</value>
                    </set-header>
                    <!-- Setting preventing CSP misuse; extended by proposed of OSO - Munzur - 8-3-2019-->
                    <set-header name="Content-Security-Policy" exists-action="override">
                        <value>frame-ancestors 'none'; default-src 'none'; script-src 'self'</value>
                    </set-header>
                    <!-- Adjusting Pragma-value (not sure if needed?)-->
                    <set-header name="Pragma" exists-action="override">
                        <value>no-cache</value>
                    </set-header>
                    <!-- Adjusting Cache-control-value (not sure if needed?)-->
                    <set-header name="Cache-control" exists-action="override">
                        <value>no-cache</value>
                    </set-header>
                    <!-- Adjusting Referrer-Policy value (Disable referrers for browsers that don't support strict-origin-when-cross-origin; Uses strict-origin-when-cross-origin for browsers that do)-->
                    <set-header name="Referrer-Policy" exists-action="override">
                        <value>no-referrer, strict-origin-when-cross-origin</value>
                    </set-header>
                    <!-- Prevent CORS with whitelist origin domain-->
                    <set-header name="Access-Control-Allow-Origin" exists-action="override">
                        <value>{{BasicAuth_AccessControlAllowOrigin}}</value>
                    </set-header>
                    <!-- Setting XSS protection; no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-XSS-Protection">
                        <value>1; mode=block</value>
                    </set-header>
                    <!-- Prevents content type from being exposed (needs to be set); no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-Content-Type-Options">
                        <value>nosniff</value>
                    </set-header>
                    <!-- Additional proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-Permitted-Cross-Domain-Policies">
                        <value>none</value>
                    </set-header>
                    <set-body>@{
                          string code = "ServerError";
                          string message = "Internal server error occurred while processing your request.";
                          string formattedBody = string.Empty;
                          if((string)context.Variables["contentType"] == "application/json"){
                              formattedBody = string.Format((string)context.Variables["jsonErrorFormat"], code, message);
                          }
                          else{
                              formattedBody = string.Format((string)context.Variables["xmlErrorFormat"], message);
                          }
                          return formattedBody;
                    }</set-body>
                </return-response>
            </when>
            <when condition="@((string)context.Variables["functionAppReqStatus"] == "200")">
                <set-variable name="username" value="@((string)((IResponse)context.Variables["functionAppReq"]).Body.As<JObject>()["userName"].ToString())" />
            </when>
            <when condition="@((string)context.Variables["functionAppReqStatus"] != "200" && (string)context.Variables["functionAppReqStatus"] != "401" && (string)context.Variables["functionAppReqStatus"] != "422" && (string)context.Variables["functionAppReqStatus"] != "500")">
                <return-response response-variable-name="functionAppReq">
                    <!-- Introduce headers as result of Pen-test recommendations -->
                    <!-- Removal commented; in fact header is needed to prevent downgrade attacks - enforcing HTTPS-->
                    <!--set-header name="Strict-Transport-Security" exists-action="delete" /-->
                    <!-- Setting preventing Downgrade attacks-->
                    <set-header name="Strict-Transport-Security" exists-action="override">
                        <value>max-age=31536000; includeSubDomains</value>
                    </set-header>
                    <!-- Setting preventing Clickjacking attacks-->
                    <set-header name="X-Frame-Options" exists-action="override">
                        <value>Deny</value>
                    </set-header>
                    <!-- Setting preventing CSP misuse; extended by proposed of OSO - Munzur - 8-3-2019-->
                    <set-header name="Content-Security-Policy" exists-action="override">
                        <value>frame-ancestors 'none'; default-src 'none'; script-src 'self'</value>
                    </set-header>
                    <!-- Adjusting Pragma-value (not sure if needed?)-->
                    <set-header name="Pragma" exists-action="override">
                        <value>no-cache</value>
                    </set-header>
                    <!-- Adjusting Cache-control-value (not sure if needed?)-->
                    <set-header name="Cache-control" exists-action="override">
                        <value>no-cache</value>
                    </set-header>
                    <!-- Adjusting Referrer-Policy value (Disable referrers for browsers that don't support strict-origin-when-cross-origin; Uses strict-origin-when-cross-origin for browsers that do)-->
                    <set-header name="Referrer-Policy" exists-action="override">
                        <value>no-referrer, strict-origin-when-cross-origin</value>
                    </set-header>
                    <!-- Prevent CORS with whitelist origin domain-->
                    <set-header name="Access-Control-Allow-Origin" exists-action="override">
                        <value>{{BasicAuth_AccessControlAllowOrigin}}</value>
                    </set-header>
                    <!-- Setting XSS protection; no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-XSS-Protection">
                        <value>1; mode=block</value>
                    </set-header>
                    <!-- Prevents content type from being exposed (needs to be set); no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-Content-Type-Options">
                        <value>nosniff</value>
                    </set-header>
                    <!-- Additional proposed by OSO - Munzur - 8-3-2019-->
                    <set-header exists-action="override" name="X-Permitted-Cross-Domain-Policies">
                        <value>none</value>
                    </set-header>
                </return-response>
            </when>
        </choose>
        <!-- Remove Authorization header to authenticate Logic App -->
        <set-header name="Authorization" exists-action="delete" />
        <set-header name="username" exists-action="override">
            <value>@((string)context.Variables["username"])</value>
        </set-header>
        <set-header name="api" exists-action="override">
            <value>@((string)context.Api.Name)</value>
        </set-header>
        <set-header name="Content-Type" exists-action="override">
            <value>@((string)context.Variables["contentTypeHeader"])</value>
        </set-header>
        <set-header name="apiOperationMethod" exists-action="override">
            <value>@((string)context.Operation.Method)</value>
        </set-header>
        <set-header name="apiOperationName" exists-action="override">
            <value>@((string)context.Operation.Name)</value>
        </set-header>
        <set-header name="password" exists-action="override">
            <value>*sanitized by policy*</value>
        </set-header>
        <!-- Forward only the body of the SOAP message and forget the SOAP Header info so the credentials are not forwarded to the receive app -->
        <set-body>@(context.Request.Body.AsSoap(true).Body.Contents.ToString())</set-body>
        <base />
    </inbound>
    <backend>
        <base />
    </backend>
    <outbound>
        <!-- Introduce headers as result of Pen-test recommendations -->
        <!-- Removal commented; in fact header is needed to prevent downgrade attacks - enforcing HTTPS-->
        <!--set-header name="Strict-Transport-Security" exists-action="delete" /-->
        <!-- Setting preventing Downgrade attacks-->
        <set-header name="Strict-Transport-Security" exists-action="override">
            <value>max-age=31536000; includeSubDomains</value>
        </set-header>
        <!-- Setting preventing Clickjacking attacks-->
        <set-header name="X-Frame-Options" exists-action="override">
            <value>Deny</value>
        </set-header>
        <!-- Setting preventing CSP misuse; extended by proposed of OSO - Munzur - 8-3-2019-->
        <set-header name="Content-Security-Policy" exists-action="override">
            <value>frame-ancestors 'none'; default-src 'none'; script-src 'self'</value>
        </set-header>
        <!-- Adjusting Pragma-value (not sure if needed?)-->
        <set-header name="Pragma" exists-action="override">
            <value>no-cache</value>
        </set-header>
        <!-- Adjusting Cache-control-value (not sure if needed?)-->
        <set-header name="Cache-control" exists-action="override">
            <value>no-cache</value>
        </set-header>
        <!-- Adjusting Referrer-Policy value (Disable referrers for browsers that don't support strict-origin-when-cross-origin; Uses strict-origin-when-cross-origin for browsers that do)-->
        <set-header name="Referrer-Policy" exists-action="override">
            <value>no-referrer, strict-origin-when-cross-origin</value>
        </set-header>
        <!-- Prevent CORS with whitelist origin domain-->
        <set-header name="Access-Control-Allow-Origin" exists-action="override">
            <value>{{BasicAuth_AccessControlAllowOrigin}}</value>
        </set-header>
        <!-- Setting XSS protection; no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
        <set-header exists-action="override" name="X-XSS-Protection">
            <value>1; mode=block</value>
        </set-header>
        <!-- Prevents content type from being exposed (needs to be set); no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
        <set-header exists-action="override" name="X-Content-Type-Options">
            <value>nosniff</value>
        </set-header>
        <!-- Additional proposed by OSO - Munzur - 8-3-2019-->
        <set-header exists-action="override" name="X-Permitted-Cross-Domain-Policies">
            <value>none</value>
        </set-header>
        <base />
    </outbound>
    <on-error>
        <base />
        <set-variable name="contentType" value="@{
            if(context.Api.Name.Contains("SOAP")){
                return "text/xml";
            }
            return "application/json";
            }" />
        <set-variable name="jsonErrorFormat" value="@{
            return "{{\"error\": {{\"code\": \"{0}\", \"message\": \"{1}\"}}}}";
            }" />
        <set-variable name="xmlErrorFormat" value="@{
            return "<s:Envelope xmlns:s='http://schemas.xmlsoap.org/soap/envelope/'><s:Body><s:Fault><faultcode>s:Client</faultcode><faultstring xml:lang='en-IN'>{0}</faultstring></s:Fault></s:Body></s:Envelope>";
            }" />
        <return-response>
            <set-status code="@(context.Response.StatusCode)" reason="@(context.LastError.Reason)" />
            <set-header name="ErrorSource" exists-action="override">
                <value>@(context.LastError.Source)</value>
            </set-header>
            <set-header name="ErrorScope" exists-action="override">
                <value>@(context.LastError.Scope)</value>
            </set-header>
            <set-header name="ErrorSection" exists-action="override">
                <value>@(context.LastError.Section)</value>
            </set-header>
            <set-header name="ErrorPath" exists-action="override">
                <value>@(context.LastError.Path)</value>
            </set-header>
            <set-header name="Content-Type" exists-action="override">
                <value>@((string)context.Variables["contentType"])</value>
            </set-header>
            <!-- Introduce headers as result of Pen-test recommendations -->
            <!-- Removal commented; in fact header is needed to prevent downgrade attacks - enforcing HTTPS-->
            <!--set-header name="Strict-Transport-Security" exists-action="delete" /-->
            <!-- Setting preventing Downgrade attacks-->
            <set-header name="Strict-Transport-Security" exists-action="override">
                <value>max-age=31536000; includeSubDomains</value>
            </set-header>
            <!-- Setting preventing Clickjacking attacks-->
            <set-header name="X-Frame-Options" exists-action="override">
                <value>Deny</value>
            </set-header>
            <!-- Setting preventing CSP misuse; extended by proposed of OSO - Munzur - 8-3-2019-->
            <set-header name="Content-Security-Policy" exists-action="override">
                <value>frame-ancestors 'none'; default-src 'none'; script-src 'self'</value>
            </set-header>
            <!-- Adjusting Pragma-value (not sure if needed?)-->
            <set-header name="Pragma" exists-action="override">
                <value>no-cache</value>
            </set-header>
            <!-- Adjusting Cache-control-value (not sure if needed?)-->
            <set-header name="Cache-control" exists-action="override">
                <value>no-cache</value>
            </set-header>
            <!-- Adjusting Referrer-Policy value (Disable referrers for browsers that don't support strict-origin-when-cross-origin; Uses strict-origin-when-cross-origin for browsers that do)-->
            <set-header name="Referrer-Policy" exists-action="override">
                <value>no-referrer, strict-origin-when-cross-origin</value>
            </set-header>
            <!-- Prevent CORS with whitelist origin domain-->
            <set-header name="Access-Control-Allow-Origin" exists-action="override">
                <value>{{BasicAuth_AccessControlAllowOrigin}}</value>
            </set-header>
            <!-- Setting XSS protection; no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
            <set-header exists-action="override" name="X-XSS-Protection">
                <value>1; mode=block</value>
            </set-header>
            <!-- Prevents content type from being exposed (needs to be set); no confirmed benefit for API, yet proposed by OSO - Munzur - 8-3-2019-->
            <set-header exists-action="override" name="X-Content-Type-Options">
                <value>nosniff</value>
            </set-header>
            <!-- Additional proposed by OSO - Munzur - 8-3-2019-->
            <set-header exists-action="override" name="X-Permitted-Cross-Domain-Policies">
                <value>none</value>
            </set-header>
            <set-body>@{
              // send response with last error message
              string code = "APIManagementError";
              string message = context.LastError.Message;
              string formattedBody = string.Empty;
              if((string)context.Variables["contentType"] == "application/json"){
                  formattedBody = string.Format((string)context.Variables["jsonErrorFormat"], code, message);
              }
              else{
                  formattedBody = string.Format((string)context.Variables["xmlErrorFormat"], message);
              }
              return formattedBody;
          }</set-body>
        </return-response>
    </on-error>
</policies>